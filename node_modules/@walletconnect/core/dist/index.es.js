import Ft,{EventEmitter as A}from"events";import $t from"@walletconnect/keyvaluestorage";import{HEARTBEAT_EVENTS as X,HeartBeat as Mt}from"@walletconnect/heartbeat";import{generateChildLogger as m,getLoggerContext as f,pino as ge,getDefaultLoggerOptions as pe}from"@walletconnect/logger";import{IMessageTracker as Kt,IPublisher as Bt,ISubscriber as kt,IRelayer as jt,IStore as Vt,IJsonRpcHistory as qt,IExpirer as Gt,IVerify as Yt,ICore as Jt}from"@walletconnect/types";import{safeJsonStringify as Ht,safeJsonParse as Xt}from"@walletconnect/safe-json";import*as B from"@walletconnect/relay-auth";import{getInternalError as c,mapToObj as De,objToMap as ye,generateKeyPair as Wt,generateRandomBytes32 as W,deriveSymKey as Zt,hashKey as Qt,validateEncoding as ei,isTypeOneEnvelope as be,encrypt as ti,validateDecoding as ii,decrypt as si,deserialize as me,decodeTypeByte as ri,BASE16 as ni,hashMessage as k,getRelayProtocolName as Z,createExpiringPromise as j,getRelayProtocolApi as V,isUndefined as Q,getSdkError as F,isValidArray as ai,formatRelayRpcUrl as oi,isProposalStruct as hi,isSessionStruct as ci,TYPE_1 as ui,calcExpiry as q,formatUri as li,parseUri as di,createDelayedPromise as gi,engineEvent as ee,isExpired as fe,isValidParams as te,isValidUrl as pi,isValidString as Di,parseExpirerTarget as yi,formatTopicTarget as bi,formatIdTarget as mi,isReactNative as fi,isBrowser as Ei,isNode as wi}from"@walletconnect/utils";import{toString as vi}from"uint8arrays";import{ONE_DAY as z,SIX_HOURS as Ii,ONE_SECOND as Ci,THIRTY_DAYS as ie,FIVE_SECONDS as se,THIRTY_SECONDS as Ee,Watch as _i,toMiliseconds as we,FIVE_MINUTES as ve}from"@walletconnect/time";import{JsonRpcProvider as Ri}from"@walletconnect/jsonrpc-provider";import{isJsonRpcRequest as Ie,formatJsonRpcResult as Ce,formatJsonRpcRequest as _e,formatJsonRpcError as Si,isJsonRpcResult as Ti,isJsonRpcError as Re,isJsonRpcResponse as Pi}from"@walletconnect/jsonrpc-utils";import xi from"@walletconnect/jsonrpc-ws-connection";import Oi from"lodash.isequal";function Ai(r,e){if(r.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),i=0;i<t.length;i++)t[i]=255;for(var s=0;s<r.length;s++){var a=r.charAt(s),n=a.charCodeAt(0);if(t[n]!==255)throw new TypeError(a+" is ambiguous");t[n]=s}var o=r.length,h=r.charAt(0),d=Math.log(o)/Math.log(256),l=Math.log(256)/Math.log(o);function g(u){if(u instanceof Uint8Array||(ArrayBuffer.isView(u)?u=new Uint8Array(u.buffer,u.byteOffset,u.byteLength):Array.isArray(u)&&(u=Uint8Array.from(u))),!(u instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(u.length===0)return"";for(var y=0,O=0,w=0,_=u.length;w!==_&&u[w]===0;)w++,y++;for(var R=(_-w)*l+1>>>0,b=new Uint8Array(R);w!==_;){for(var S=u[w],x=0,v=R-1;(S!==0||x<O)&&v!==-1;v--,x++)S+=256*b[v]>>>0,b[v]=S%o>>>0,S=S/o>>>0;if(S!==0)throw new Error("Non-zero carry");O=x,w++}for(var T=R-O;T!==R&&b[T]===0;)T++;for(var K=h.repeat(y);T<R;++T)K+=r.charAt(b[T]);return K}function L(u){if(typeof u!="string")throw new TypeError("Expected String");if(u.length===0)return new Uint8Array;var y=0;if(u[y]!==" "){for(var O=0,w=0;u[y]===h;)O++,y++;for(var _=(u.length-y)*d+1>>>0,R=new Uint8Array(_);u[y];){var b=t[u.charCodeAt(y)];if(b===255)return;for(var S=0,x=_-1;(b!==0||S<w)&&x!==-1;x--,S++)b+=o*R[x]>>>0,R[x]=b%256>>>0,b=b/256>>>0;if(b!==0)throw new Error("Non-zero carry");w=S,y++}if(u[y]!==" "){for(var v=_-w;v!==_&&R[v]===0;)v++;for(var T=new Uint8Array(O+(_-v)),K=O;v!==_;)T[K++]=R[v++];return T}}}function H(u){var y=L(u);if(y)return y;throw new Error(`Non-${e} character`)}return{encode:g,decodeUnsafe:L,decode:H}}var zi=Ai,Ni=zi;const Se=r=>{if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")},Ui=r=>new TextEncoder().encode(r),Li=r=>new TextDecoder().decode(r);class Fi{constructor(e,t,i){this.name=e,this.prefix=t,this.baseEncode=i}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class $i{constructor(e,t,i){if(this.name=e,this.prefix=t,t.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=i}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return Te(this,e)}}class Mi{constructor(e){this.decoders=e}or(e){return Te(this,e)}decode(e){const t=e[0],i=this.decoders[t];if(i)return i.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const Te=(r,e)=>new Mi({...r.decoders||{[r.prefix]:r},...e.decoders||{[e.prefix]:e}});class Ki{constructor(e,t,i,s){this.name=e,this.prefix=t,this.baseEncode=i,this.baseDecode=s,this.encoder=new Fi(e,t,i),this.decoder=new $i(e,t,s)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const G=({name:r,prefix:e,encode:t,decode:i})=>new Ki(r,e,t,i),$=({prefix:r,name:e,alphabet:t})=>{const{encode:i,decode:s}=Ni(t,e);return G({prefix:r,name:e,encode:i,decode:a=>Se(s(a))})},Bi=(r,e,t,i)=>{const s={};for(let l=0;l<e.length;++l)s[e[l]]=l;let a=r.length;for(;r[a-1]==="=";)--a;const n=new Uint8Array(a*t/8|0);let o=0,h=0,d=0;for(let l=0;l<a;++l){const g=s[r[l]];if(g===void 0)throw new SyntaxError(`Non-${i} character`);h=h<<t|g,o+=t,o>=8&&(o-=8,n[d++]=255&h>>o)}if(o>=t||255&h<<8-o)throw new SyntaxError("Unexpected end of data");return n},ki=(r,e,t)=>{const i=e[e.length-1]==="=",s=(1<<t)-1;let a="",n=0,o=0;for(let h=0;h<r.length;++h)for(o=o<<8|r[h],n+=8;n>t;)n-=t,a+=e[s&o>>n];if(n&&(a+=e[s&o<<t-n]),i)for(;a.length*t&7;)a+="=";return a},p=({name:r,prefix:e,bitsPerChar:t,alphabet:i})=>G({prefix:e,name:r,encode(s){return ki(s,i,t)},decode(s){return Bi(s,i,t,r)}}),ji=G({prefix:"\0",name:"identity",encode:r=>Li(r),decode:r=>Ui(r)});var Vi=Object.freeze({__proto__:null,identity:ji});const qi=p({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var Gi=Object.freeze({__proto__:null,base2:qi});const Yi=p({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var Ji=Object.freeze({__proto__:null,base8:Yi});const Hi=$({prefix:"9",name:"base10",alphabet:"0123456789"});var Xi=Object.freeze({__proto__:null,base10:Hi});const Wi=p({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Zi=p({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var Qi=Object.freeze({__proto__:null,base16:Wi,base16upper:Zi});const es=p({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),ts=p({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),is=p({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),ss=p({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),rs=p({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),ns=p({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),as=p({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),os=p({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),hs=p({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var cs=Object.freeze({__proto__:null,base32:es,base32upper:ts,base32pad:is,base32padupper:ss,base32hex:rs,base32hexupper:ns,base32hexpad:as,base32hexpadupper:os,base32z:hs});const us=$({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),ls=$({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var ds=Object.freeze({__proto__:null,base36:us,base36upper:ls});const gs=$({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),ps=$({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var Ds=Object.freeze({__proto__:null,base58btc:gs,base58flickr:ps});const ys=p({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),bs=p({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),ms=p({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),fs=p({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var Es=Object.freeze({__proto__:null,base64:ys,base64pad:bs,base64url:ms,base64urlpad:fs});const Pe=Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"),ws=Pe.reduce((r,e,t)=>(r[t]=e,r),[]),vs=Pe.reduce((r,e,t)=>(r[e.codePointAt(0)]=t,r),[]);function Is(r){return r.reduce((e,t)=>(e+=ws[t],e),"")}function Cs(r){const e=[];for(const t of r){const i=vs[t.codePointAt(0)];if(i===void 0)throw new Error(`Non-base256emoji character: ${t}`);e.push(i)}return new Uint8Array(e)}const _s=G({prefix:"\u{1F680}",name:"base256emoji",encode:Is,decode:Cs});var Rs=Object.freeze({__proto__:null,base256emoji:_s}),Ss=Oe,xe=128,Ts=127,Ps=~Ts,xs=Math.pow(2,31);function Oe(r,e,t){e=e||[],t=t||0;for(var i=t;r>=xs;)e[t++]=r&255|xe,r/=128;for(;r&Ps;)e[t++]=r&255|xe,r>>>=7;return e[t]=r|0,Oe.bytes=t-i+1,e}var Os=re,As=128,Ae=127;function re(r,i){var t=0,i=i||0,s=0,a=i,n,o=r.length;do{if(a>=o)throw re.bytes=0,new RangeError("Could not decode varint");n=r[a++],t+=s<28?(n&Ae)<<s:(n&Ae)*Math.pow(2,s),s+=7}while(n>=As);return re.bytes=a-i,t}var zs=Math.pow(2,7),Ns=Math.pow(2,14),Us=Math.pow(2,21),Ls=Math.pow(2,28),Fs=Math.pow(2,35),$s=Math.pow(2,42),Ms=Math.pow(2,49),Ks=Math.pow(2,56),Bs=Math.pow(2,63),ks=function(r){return r<zs?1:r<Ns?2:r<Us?3:r<Ls?4:r<Fs?5:r<$s?6:r<Ms?7:r<Ks?8:r<Bs?9:10},js={encode:Ss,decode:Os,encodingLength:ks},ze=js;const Ne=(r,e,t=0)=>(ze.encode(r,e,t),e),Ue=r=>ze.encodingLength(r),ne=(r,e)=>{const t=e.byteLength,i=Ue(r),s=i+Ue(t),a=new Uint8Array(s+t);return Ne(r,a,0),Ne(t,a,i),a.set(e,s),new Vs(r,t,e,a)};class Vs{constructor(e,t,i,s){this.code=e,this.size=t,this.digest=i,this.bytes=s}}const Le=({name:r,code:e,encode:t})=>new qs(r,e,t);class qs{constructor(e,t,i){this.name=e,this.code=t,this.encode=i}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?ne(this.code,t):t.then(i=>ne(this.code,i))}else throw Error("Unknown type, must be binary type")}}const Fe=r=>async e=>new Uint8Array(await crypto.subtle.digest(r,e)),Gs=Le({name:"sha2-256",code:18,encode:Fe("SHA-256")}),Ys=Le({name:"sha2-512",code:19,encode:Fe("SHA-512")});var Js=Object.freeze({__proto__:null,sha256:Gs,sha512:Ys});const $e=0,Hs="identity",Me=Se,Xs=r=>ne($e,Me(r)),Ws={code:$e,name:Hs,encode:Me,digest:Xs};var Zs=Object.freeze({__proto__:null,identity:Ws});new TextEncoder,new TextDecoder;const Ke={...Vi,...Gi,...Ji,...Xi,...Qi,...cs,...ds,...Ds,...Es,...Rs};({...Js,...Zs});function Be(r){return globalThis.Buffer!=null?new Uint8Array(r.buffer,r.byteOffset,r.byteLength):r}function Qs(r=0){return globalThis.Buffer!=null&&globalThis.Buffer.allocUnsafe!=null?Be(globalThis.Buffer.allocUnsafe(r)):new Uint8Array(r)}function ke(r,e,t,i){return{name:r,prefix:e,encoder:{name:r,prefix:e,encode:t},decoder:{decode:i}}}const je=ke("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),ae=ke("ascii","a",r=>{let e="a";for(let t=0;t<r.length;t++)e+=String.fromCharCode(r[t]);return e},r=>{r=r.substring(1);const e=Qs(r.length);for(let t=0;t<r.length;t++)e[t]=r.charCodeAt(t);return e}),er={utf8:je,"utf-8":je,hex:Ke.base16,latin1:ae,ascii:ae,binary:ae,...Ke};function tr(r,e="utf8"){const t=er[e];if(!t)throw new Error(`Unsupported encoding "${e}"`);return(e==="utf8"||e==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?Be(globalThis.Buffer.from(r,"utf-8")):t.decoder.decode(`${t.prefix}${r}`)}const oe="wc",Ve=2,Y="core",P=`${oe}@${2}:${Y}:`,qe={name:Y,logger:"error"},Ge={database:":memory:"},Ye="crypto",he="client_ed25519_seed",Je=z,He="keychain",Xe="0.3",We="messages",Ze="0.3",Qe=Ii,et="publisher",tt="irn",it="error",ce="wss://relay.walletconnect.com",st="relayer",D={message:"relayer_message",connect:"relayer_connect",disconnect:"relayer_disconnect",error:"relayer_error",connection_stalled:"relayer_connection_stalled",transport_closed:"relayer_transport_closed",publish:"relayer_publish"},rt="_subscription",N={payload:"payload",connect:"connect",disconnect:"disconnect",error:"error"},nt=Ci/2,ir={database:":memory:"},at="2.7.2",ot="0.3",I={created:"subscription_created",deleted:"subscription_deleted",expired:"subscription_expired",disabled:"subscription_disabled",sync:"subscription_sync",resubscribed:"subscription_resubscribed"},sr=ie,ht="subscription",ct="0.3",ut=se*1e3,lt="pairing",dt="0.3",rr=ie,U={wc_pairingDelete:{req:{ttl:z,prompt:!1,tag:1e3},res:{ttl:z,prompt:!1,tag:1001}},wc_pairingPing:{req:{ttl:Ee,prompt:!1,tag:1002},res:{ttl:Ee,prompt:!1,tag:1003}},unregistered_method:{req:{ttl:z,prompt:!1,tag:0},res:{ttl:z,prompt:!1,tag:0}}},C={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},gt="history",pt="0.3",Dt="expirer",E={created:"expirer_created",deleted:"expirer_deleted",expired:"expirer_expired",sync:"expirer_sync"},yt="0.3",nr=z,ue="verify-api",le="https://verify.walletconnect.com";class bt{constructor(e,t){this.core=e,this.logger=t,this.keychain=new Map,this.name=He,this.version=Xe,this.initialized=!1,this.storagePrefix=P,this.init=async()=>{if(!this.initialized){const i=await this.getKeyChain();typeof i<"u"&&(this.keychain=i),this.initialized=!0}},this.has=i=>(this.isInitialized(),this.keychain.has(i)),this.set=async(i,s)=>{this.isInitialized(),this.keychain.set(i,s),await this.persist()},this.get=i=>{this.isInitialized();const s=this.keychain.get(i);if(typeof s>"u"){const{message:a}=c("NO_MATCHING_KEY",`${this.name}: ${i}`);throw new Error(a)}return s},this.del=async i=>{this.isInitialized(),this.keychain.delete(i),await this.persist()},this.core=e,this.logger=m(t,this.name)}get context(){return f(this.logger)}get storageKey(){return this.storagePrefix+this.version+"//"+this.name}async setKeyChain(e){await this.core.storage.setItem(this.storageKey,De(e))}async getKeyChain(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<"u"?ye(e):void 0}async persist(){await this.setKeyChain(this.keychain)}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}class mt{constructor(e,t,i){this.core=e,this.logger=t,this.name=Ye,this.initialized=!1,this.init=async()=>{this.initialized||(await this.keychain.init(),this.initialized=!0)},this.hasKeys=s=>(this.isInitialized(),this.keychain.has(s)),this.getClientId=async()=>{this.isInitialized();const s=await this.getClientSeed(),a=B.generateKeyPair(s);return B.encodeIss(a.publicKey)},this.generateKeyPair=()=>{this.isInitialized();const s=Wt();return this.setPrivateKey(s.publicKey,s.privateKey)},this.signJWT=async s=>{this.isInitialized();const a=await this.getClientSeed(),n=B.generateKeyPair(a),o=W(),h=Je;return await B.signJWT(o,s,h,n)},this.generateSharedKey=(s,a,n)=>{this.isInitialized();const o=this.getPrivateKey(s),h=Zt(o,a);return this.setSymKey(h,n)},this.setSymKey=async(s,a)=>{this.isInitialized();const n=a||Qt(s);return await this.keychain.set(n,s),n},this.deleteKeyPair=async s=>{this.isInitialized(),await this.keychain.del(s)},this.deleteSymKey=async s=>{this.isInitialized(),await this.keychain.del(s)},this.encode=async(s,a,n)=>{this.isInitialized();const o=ei(n),h=Ht(a);if(be(o)){const L=o.senderPublicKey,H=o.receiverPublicKey;s=await this.generateSharedKey(L,H)}const d=this.getSymKey(s),{type:l,senderPublicKey:g}=o;return ti({type:l,symKey:d,message:h,senderPublicKey:g})},this.decode=async(s,a,n)=>{this.isInitialized();const o=ii(a,n);if(be(o)){const l=o.receiverPublicKey,g=o.senderPublicKey;s=await this.generateSharedKey(l,g)}const h=this.getSymKey(s),d=si({symKey:h,encoded:a});return Xt(d)},this.getPayloadType=s=>{const a=me(s);return ri(a.type)},this.getPayloadSenderPublicKey=s=>{const a=me(s);return a.senderPublicKey?vi(a.senderPublicKey,ni):void 0},this.core=e,this.logger=m(t,this.name),this.keychain=i||new bt(this.core,this.logger)}get context(){return f(this.logger)}async setPrivateKey(e,t){return await this.keychain.set(e,t),e}getPrivateKey(e){return this.keychain.get(e)}async getClientSeed(){let e="";try{e=this.keychain.get(he)}catch{e=W(),await this.keychain.set(he,e)}return tr(e,"base16")}getSymKey(e){return this.keychain.get(e)}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}class ft extends Kt{constructor(e,t){super(e,t),this.logger=e,this.core=t,this.messages=new Map,this.name=We,this.version=Ze,this.initialized=!1,this.storagePrefix=P,this.init=async()=>{if(!this.initialized){this.logger.trace("Initialized");try{const i=await this.getRelayerMessages();typeof i<"u"&&(this.messages=i),this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",size:this.messages.size})}catch(i){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(i)}finally{this.initialized=!0}}},this.set=async(i,s)=>{this.isInitialized();const a=k(s);let n=this.messages.get(i);return typeof n>"u"&&(n={}),typeof n[a]<"u"||(n[a]=s,this.messages.set(i,n),await this.persist()),a},this.get=i=>{this.isInitialized();let s=this.messages.get(i);return typeof s>"u"&&(s={}),s},this.has=(i,s)=>{this.isInitialized();const a=this.get(i),n=k(s);return typeof a[n]<"u"},this.del=async i=>{this.isInitialized(),this.messages.delete(i),await this.persist()},this.logger=m(e,this.name),this.core=t}get context(){return f(this.logger)}get storageKey(){return this.storagePrefix+this.version+"//"+this.name}async setRelayerMessages(e){await this.core.storage.setItem(this.storageKey,De(e))}async getRelayerMessages(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<"u"?ye(e):void 0}async persist(){await this.setRelayerMessages(this.messages)}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}class ar extends Bt{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,this.events=new A,this.name=et,this.queue=new Map,this.publishTimeout=1e4,this.publish=async(i,s,a)=>{this.logger.debug("Publishing Payload"),this.logger.trace({type:"method",method:"publish",params:{topic:i,message:s,opts:a}});try{const n=a?.ttl||Qe,o=Z(a),h=a?.prompt||!1,d=a?.tag||0,l={topic:i,message:s,opts:{ttl:n,relay:o,prompt:h,tag:d}},g=k(s);this.queue.set(g,l);try{await await j(this.rpcPublish(i,s,n,o,h,d),this.publishTimeout),this.relayer.events.emit(D.publish,l)}catch{this.logger.debug("Publishing Payload stalled"),this.relayer.events.emit(D.connection_stalled);return}this.onPublish(g,l),this.logger.debug("Successfully Published Payload"),this.logger.trace({type:"method",method:"publish",params:{topic:i,message:s,opts:a}})}catch(n){throw this.logger.debug("Failed to Publish Payload"),this.logger.error(n),n}},this.on=(i,s)=>{this.events.on(i,s)},this.once=(i,s)=>{this.events.once(i,s)},this.off=(i,s)=>{this.events.off(i,s)},this.removeListener=(i,s)=>{this.events.removeListener(i,s)},this.relayer=e,this.logger=m(t,this.name),this.registerEventListeners()}get context(){return f(this.logger)}rpcPublish(e,t,i,s,a,n){var o,h,d,l;const g={method:V(s.protocol).publish,params:{topic:e,message:t,ttl:i,prompt:a,tag:n}};return Q((o=g.params)==null?void 0:o.prompt)&&((h=g.params)==null||delete h.prompt),Q((d=g.params)==null?void 0:d.tag)&&((l=g.params)==null||delete l.tag),this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"message",direction:"outgoing",request:g}),this.relayer.request(g)}onPublish(e,t){this.queue.delete(e)}checkQueue(){this.queue.forEach(async e=>{const{topic:t,message:i,opts:s}=e;await this.publish(t,i,s)})}registerEventListeners(){this.relayer.core.heartbeat.on(X.pulse,()=>{this.checkQueue()})}}class or{constructor(){this.map=new Map,this.set=(e,t)=>{const i=this.get(e);this.exists(e,t)||this.map.set(e,[...i,t])},this.get=e=>this.map.get(e)||[],this.exists=(e,t)=>this.get(e).includes(t),this.delete=(e,t)=>{if(typeof t>"u"){this.map.delete(e);return}if(!this.map.has(e))return;const i=this.get(e);if(!this.exists(e,t))return;const s=i.filter(a=>a!==t);if(!s.length){this.map.delete(e);return}this.map.set(e,s)},this.clear=()=>{this.map.clear()}}get topics(){return Array.from(this.map.keys())}}var hr=Object.defineProperty,cr=Object.defineProperties,ur=Object.getOwnPropertyDescriptors,Et=Object.getOwnPropertySymbols,lr=Object.prototype.hasOwnProperty,dr=Object.prototype.propertyIsEnumerable,wt=(r,e,t)=>e in r?hr(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,M=(r,e)=>{for(var t in e||(e={}))lr.call(e,t)&&wt(r,t,e[t]);if(Et)for(var t of Et(e))dr.call(e,t)&&wt(r,t,e[t]);return r},de=(r,e)=>cr(r,ur(e));class vt extends kt{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,this.subscriptions=new Map,this.topicMap=new or,this.events=new A,this.name=ht,this.version=ct,this.pending=new Map,this.cached=[],this.initialized=!1,this.pendingSubscriptionWatchLabel="pending_sub_watch_label",this.pollingInterval=20,this.storagePrefix=P,this.subscribeTimeout=1e4,this.restartInProgress=!1,this.batchSubscribeTopicsLimit=500,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restart(),this.registerEventListeners(),this.onEnable(),this.clientId=await this.relayer.core.crypto.getClientId())},this.subscribe=async(i,s)=>{await this.restartToComplete(),this.isInitialized(),this.logger.debug("Subscribing Topic"),this.logger.trace({type:"method",method:"subscribe",params:{topic:i,opts:s}});try{const a=Z(s),n={topic:i,relay:a};this.pending.set(i,n);const o=await this.rpcSubscribe(i,a);return this.onSubscribe(o,n),this.logger.debug("Successfully Subscribed Topic"),this.logger.trace({type:"method",method:"subscribe",params:{topic:i,opts:s}}),o}catch(a){throw this.logger.debug("Failed to Subscribe Topic"),this.logger.error(a),a}},this.unsubscribe=async(i,s)=>{await this.restartToComplete(),this.isInitialized(),typeof s?.id<"u"?await this.unsubscribeById(i,s.id,s):await this.unsubscribeByTopic(i,s)},this.isSubscribed=async i=>this.topics.includes(i)?!0:await new Promise((s,a)=>{const n=new _i;n.start(this.pendingSubscriptionWatchLabel);const o=setInterval(()=>{!this.pending.has(i)&&this.topics.includes(i)&&(clearInterval(o),n.stop(this.pendingSubscriptionWatchLabel),s(!0)),n.elapsed(this.pendingSubscriptionWatchLabel)>=ut&&(clearInterval(o),n.stop(this.pendingSubscriptionWatchLabel),a(!1))},this.pollingInterval)}),this.on=(i,s)=>{this.events.on(i,s)},this.once=(i,s)=>{this.events.once(i,s)},this.off=(i,s)=>{this.events.off(i,s)},this.removeListener=(i,s)=>{this.events.removeListener(i,s)},this.restart=async()=>{this.restartInProgress=!0,await this.restore(),await this.reset(),this.restartInProgress=!1},this.relayer=e,this.logger=m(t,this.name),this.clientId=""}get context(){return f(this.logger)}get storageKey(){return this.storagePrefix+this.version+"//"+this.name}get length(){return this.subscriptions.size}get ids(){return Array.from(this.subscriptions.keys())}get values(){return Array.from(this.subscriptions.values())}get topics(){return this.topicMap.topics}hasSubscription(e,t){let i=!1;try{i=this.getSubscription(e).topic===t}catch{}return i}onEnable(){this.cached=[],this.initialized=!0}onDisable(){this.cached=this.values,this.subscriptions.clear(),this.topicMap.clear()}async unsubscribeByTopic(e,t){const i=this.topicMap.get(e);await Promise.all(i.map(async s=>await this.unsubscribeById(e,s,t)))}async unsubscribeById(e,t,i){this.logger.debug("Unsubscribing Topic"),this.logger.trace({type:"method",method:"unsubscribe",params:{topic:e,id:t,opts:i}});try{const s=Z(i);await this.rpcUnsubscribe(e,t,s);const a=F("USER_DISCONNECTED",`${this.name}, ${e}`);await this.onUnsubscribe(e,t,a),this.logger.debug("Successfully Unsubscribed Topic"),this.logger.trace({type:"method",method:"unsubscribe",params:{topic:e,id:t,opts:i}})}catch(s){throw this.logger.debug("Failed to Unsubscribe Topic"),this.logger.error(s),s}}async rpcSubscribe(e,t){const i={method:V(t.protocol).subscribe,params:{topic:e}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:i});try{await await j(this.relayer.request(i),this.subscribeTimeout)}catch{this.logger.debug("Outgoing Relay Subscribe Payload stalled"),this.relayer.events.emit(D.connection_stalled)}return k(e+this.clientId)}async rpcBatchSubscribe(e){if(!e.length)return;const t=e[0].relay,i={method:V(t.protocol).batchSubscribe,params:{topics:e.map(s=>s.topic)}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:i});try{return await await j(this.relayer.request(i),this.subscribeTimeout)}catch{this.logger.debug("Outgoing Relay Payload stalled"),this.relayer.events.emit(D.connection_stalled)}}rpcUnsubscribe(e,t,i){const s={method:V(i.protocol).unsubscribe,params:{topic:e,id:t}};return this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:s}),this.relayer.request(s)}onSubscribe(e,t){this.setSubscription(e,de(M({},t),{id:e})),this.pending.delete(t.topic)}onBatchSubscribe(e){e.length&&e.forEach(t=>{this.setSubscription(t.id,M({},t)),this.pending.delete(t.topic)})}async onUnsubscribe(e,t,i){this.events.removeAllListeners(t),this.hasSubscription(t,e)&&this.deleteSubscription(t,i),await this.relayer.messages.del(e)}async setRelayerSubscriptions(e){await this.relayer.core.storage.setItem(this.storageKey,e)}async getRelayerSubscriptions(){return await this.relayer.core.storage.getItem(this.storageKey)}setSubscription(e,t){this.subscriptions.has(e)||(this.logger.debug("Setting subscription"),this.logger.trace({type:"method",method:"setSubscription",id:e,subscription:t}),this.addSubscription(e,t))}addSubscription(e,t){this.subscriptions.set(e,M({},t)),this.topicMap.set(t.topic,e),this.events.emit(I.created,t)}getSubscription(e){this.logger.debug("Getting subscription"),this.logger.trace({type:"method",method:"getSubscription",id:e});const t=this.subscriptions.get(e);if(!t){const{message:i}=c("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(i)}return t}deleteSubscription(e,t){this.logger.debug("Deleting subscription"),this.logger.trace({type:"method",method:"deleteSubscription",id:e,reason:t});const i=this.getSubscription(e);this.subscriptions.delete(e),this.topicMap.delete(i.topic,e),this.events.emit(I.deleted,de(M({},i),{reason:t}))}async persist(){await this.setRelayerSubscriptions(this.values),this.events.emit(I.sync)}async reset(){if(this.cached.length){const e=Math.ceil(this.cached.length/this.batchSubscribeTopicsLimit);for(let t=0;t<e;t++){const i=this.cached.splice(0,this.batchSubscribeTopicsLimit);await this.batchSubscribe(i)}}this.events.emit(I.resubscribed)}async restore(){try{const e=await this.getRelayerSubscriptions();if(typeof e>"u"||!e.length)return;if(this.subscriptions.size){const{message:t}=c("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored subscriptions for ${this.name}`),this.logger.trace({type:"method",method:"restore",subscriptions:this.values})}catch(e){this.logger.debug(`Failed to Restore subscriptions for ${this.name}`),this.logger.error(e)}}async batchSubscribe(e){if(!e.length)return;const t=await this.rpcBatchSubscribe(e);ai(t)&&this.onBatchSubscribe(t.map((i,s)=>de(M({},e[s]),{id:i})))}async onConnect(){this.restartInProgress||(await this.restart(),this.onEnable())}onDisconnect(){this.onDisable()}async checkPending(){if(this.relayer.transportExplicitlyClosed)return;const e=[];this.pending.forEach(t=>{e.push(t)}),await this.batchSubscribe(e)}registerEventListeners(){this.relayer.core.heartbeat.on(X.pulse,async()=>{await this.checkPending()}),this.relayer.on(D.connect,async()=>{await this.onConnect()}),this.relayer.on(D.disconnect,()=>{this.onDisconnect()}),this.events.on(I.created,async e=>{const t=I.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),await this.persist()}),this.events.on(I.deleted,async e=>{const t=I.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),await this.persist()})}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}async restartToComplete(){this.restartInProgress&&await new Promise(e=>{const t=setInterval(()=>{this.restartInProgress||(clearInterval(t),e())},this.pollingInterval)})}}var gr=Object.defineProperty,It=Object.getOwnPropertySymbols,pr=Object.prototype.hasOwnProperty,Dr=Object.prototype.propertyIsEnumerable,Ct=(r,e,t)=>e in r?gr(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,yr=(r,e)=>{for(var t in e||(e={}))pr.call(e,t)&&Ct(r,t,e[t]);if(It)for(var t of It(e))Dr.call(e,t)&&Ct(r,t,e[t]);return r};class _t extends jt{constructor(e){super(e),this.protocol="wc",this.version=2,this.events=new A,this.name=st,this.transportExplicitlyClosed=!1,this.initialized=!1,this.reconnecting=!1,this.connectionStatusPollingInterval=20,this.staleConnectionErrors=["socket hang up","socket stalled"],this.request=async t=>{this.logger.debug("Publishing Request Payload");try{return await this.toEstablishConnection(),await this.provider.request(t)}catch(i){throw this.logger.debug("Failed to Publish Request"),this.logger.error(i),i}},this.core=e.core,this.logger=typeof e.logger<"u"&&typeof e.logger!="string"?m(e.logger,this.name):ge(pe({level:e.logger||it})),this.messages=new ft(this.logger,e.core),this.subscriber=new vt(this,this.logger),this.publisher=new ar(this,this.logger),this.relayUrl=e?.relayUrl||ce,this.projectId=e.projectId,this.provider={}}async init(){this.logger.trace("Initialized"),await this.createProvider(),await Promise.all([this.messages.init(),this.transportOpen(),this.subscriber.init()]),this.registerEventListeners(),this.initialized=!0}get context(){return f(this.logger)}get connected(){return this.provider.connection.connected}get connecting(){return this.provider.connection.connecting}async publish(e,t,i){this.isInitialized(),await this.publisher.publish(e,t,i),await this.recordMessageEvent({topic:e,message:t,publishedAt:Date.now()})}async subscribe(e,t){this.isInitialized();let i="";return await Promise.all([new Promise(s=>{this.subscriber.once(I.created,a=>{a.topic===e&&s()})}),new Promise(async s=>{i=await this.subscriber.subscribe(e,t),s()})]),i}async unsubscribe(e,t){this.isInitialized(),await this.subscriber.unsubscribe(e,t)}on(e,t){this.events.on(e,t)}once(e,t){this.events.once(e,t)}off(e,t){this.events.off(e,t)}removeListener(e,t){this.events.removeListener(e,t)}async transportClose(){this.transportExplicitlyClosed=!0,this.connected&&(await this.provider.disconnect(),this.events.emit(D.transport_closed))}async transportOpen(e){if(this.transportExplicitlyClosed=!1,!this.reconnecting){this.relayUrl=e||this.relayUrl,this.reconnecting=!0;try{await Promise.all([new Promise(t=>{this.initialized||t(),this.subscriber.once(I.resubscribed,()=>{t()})}),await Promise.race([new Promise(async(t,i)=>{await j(this.provider.connect(),5e3,"socket stalled").catch(s=>i(s)).then(()=>t()).finally(()=>this.removeListener(D.transport_closed,this.rejectTransportOpen))}),new Promise(t=>this.once(D.transport_closed,this.rejectTransportOpen))])])}catch(t){this.logger.error(t);const i=t;if(!this.isConnectionStalled(i.message))throw t;this.events.emit(D.transport_closed)}finally{this.reconnecting=!1}}}async restartTransport(e){this.transportExplicitlyClosed||(this.relayUrl=e||this.relayUrl,this.connected&&await Promise.all([new Promise(t=>{this.provider.once(N.disconnect,()=>{t()})}),this.transportClose()]),await this.createProvider(),await this.transportOpen())}isConnectionStalled(e){return this.staleConnectionErrors.some(t=>e.includes(t))}rejectTransportOpen(){throw new Error("closeTransport called before connection was established")}async createProvider(){const e=await this.core.crypto.signJWT(this.relayUrl);this.provider=new Ri(new xi(oi({sdkVersion:at,protocol:this.protocol,version:this.version,relayUrl:this.relayUrl,projectId:this.projectId,auth:e,useOnCloseEvent:!0}))),this.registerProviderListeners()}async recordMessageEvent(e){const{topic:t,message:i}=e;await this.messages.set(t,i)}async shouldIgnoreMessageEvent(e){const{topic:t,message:i}=e;return await this.subscriber.isSubscribed(t)?this.messages.has(t,i):!0}async onProviderPayload(e){if(this.logger.debug("Incoming Relay Payload"),this.logger.trace({type:"payload",direction:"incoming",payload:e}),Ie(e)){if(!e.method.endsWith(rt))return;const t=e.params,{topic:i,message:s,publishedAt:a}=t.data,n={topic:i,message:s,publishedAt:a};this.logger.debug("Emitting Relayer Payload"),this.logger.trace(yr({type:"event",event:t.id},n)),this.events.emit(t.id,n),await this.acknowledgePayload(e),await this.onMessageEvent(n)}}async onMessageEvent(e){await this.shouldIgnoreMessageEvent(e)||(this.events.emit(D.message,e),await this.recordMessageEvent(e))}async acknowledgePayload(e){const t=Ce(e.id,!0);await this.provider.connection.send(t)}registerProviderListeners(){this.provider.on(N.payload,e=>this.onProviderPayload(e)),this.provider.on(N.connect,()=>{this.events.emit(D.connect)}),this.provider.on(N.disconnect,()=>{this.onProviderDisconnect()}),this.provider.on(N.error,e=>{this.logger.error(e),this.events.emit(D.error,e)})}registerEventListeners(){this.events.on(D.connection_stalled,async()=>{await this.restartTransport()})}onProviderDisconnect(){this.events.emit(D.disconnect),this.attemptToReconnect()}attemptToReconnect(){this.transportExplicitlyClosed||setTimeout(async()=>{await this.restartTransport()},we(nt))}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}async toEstablishConnection(){if(!this.connected){if(this.connecting)return await new Promise(e=>{const t=setInterval(()=>{this.connected&&(clearInterval(t),e())},this.connectionStatusPollingInterval)});await this.restartTransport()}}}var br=Object.defineProperty,Rt=Object.getOwnPropertySymbols,mr=Object.prototype.hasOwnProperty,fr=Object.prototype.propertyIsEnumerable,St=(r,e,t)=>e in r?br(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,Tt=(r,e)=>{for(var t in e||(e={}))mr.call(e,t)&&St(r,t,e[t]);if(Rt)for(var t of Rt(e))fr.call(e,t)&&St(r,t,e[t]);return r};class Pt extends Vt{constructor(e,t,i,s=P,a=void 0){super(e,t,i,s),this.core=e,this.logger=t,this.name=i,this.map=new Map,this.version=ot,this.cached=[],this.initialized=!1,this.storagePrefix=P,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(n=>{this.getKey&&n!==null&&!Q(n)?this.map.set(this.getKey(n),n):hi(n)?this.map.set(n.id,n):ci(n)&&this.map.set(n.topic,n)}),this.cached=[],this.initialized=!0)},this.set=async(n,o)=>{this.isInitialized(),this.map.has(n)?await this.update(n,o):(this.logger.debug("Setting value"),this.logger.trace({type:"method",method:"set",key:n,value:o}),this.map.set(n,o),await this.persist())},this.get=n=>(this.isInitialized(),this.logger.debug("Getting value"),this.logger.trace({type:"method",method:"get",key:n}),this.getData(n)),this.getAll=n=>(this.isInitialized(),n?this.values.filter(o=>Object.keys(n).every(h=>Oi(o[h],n[h]))):this.values),this.update=async(n,o)=>{this.isInitialized(),this.logger.debug("Updating value"),this.logger.trace({type:"method",method:"update",key:n,update:o});const h=Tt(Tt({},this.getData(n)),o);this.map.set(n,h),await this.persist()},this.delete=async(n,o)=>{this.isInitialized(),this.map.has(n)&&(this.logger.debug("Deleting value"),this.logger.trace({type:"method",method:"delete",key:n,reason:o}),this.map.delete(n),await this.persist())},this.logger=m(t,this.name),this.storagePrefix=s,this.getKey=a}get context(){return f(this.logger)}get storageKey(){return this.storagePrefix+this.version+"//"+this.name}get length(){return this.map.size}get keys(){return Array.from(this.map.keys())}get values(){return Array.from(this.map.values())}async setDataStore(e){await this.core.storage.setItem(this.storageKey,e)}async getDataStore(){return await this.core.storage.getItem(this.storageKey)}getData(e){const t=this.map.get(e);if(!t){const{message:i}=c("NO_MATCHING_KEY",`${this.name}: ${e}`);throw this.logger.error(i),new Error(i)}return t}async persist(){await this.setDataStore(this.values)}async restore(){try{const e=await this.getDataStore();if(typeof e>"u"||!e.length)return;if(this.map.size){const{message:t}=c("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored value for ${this.name}`),this.logger.trace({type:"method",method:"restore",value:this.values})}catch(e){this.logger.debug(`Failed to Restore value for ${this.name}`),this.logger.error(e)}}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}class xt{constructor(e,t){this.core=e,this.logger=t,this.name=lt,this.version=dt,this.events=new Ft,this.initialized=!1,this.storagePrefix=P,this.ignoredPayloadTypes=[ui],this.registeredMethods=[],this.init=async()=>{this.initialized||(await this.pairings.init(),await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.initialized=!0,this.logger.trace("Initialized"))},this.register=({methods:i})=>{this.isInitialized(),this.registeredMethods=[...new Set([...this.registeredMethods,...i])]},this.create=async()=>{this.isInitialized();const i=W(),s=await this.core.crypto.setSymKey(i),a=q(ve),n={protocol:tt},o={topic:s,expiry:a,relay:n,active:!1},h=li({protocol:this.core.protocol,version:this.core.version,topic:s,symKey:i,relay:n});return await this.pairings.set(s,o),await this.core.relayer.subscribe(s),this.core.expirer.set(s,a),{topic:s,uri:h}},this.pair=async i=>{this.isInitialized(),this.isValidPair(i);const{topic:s,symKey:a,relay:n}=di(i.uri);if(this.pairings.keys.includes(s))throw new Error(`Pairing already exists: ${s}`);if(this.core.crypto.hasKeys(s))throw new Error(`Keychain already exists: ${s}`);const o=q(ve),h={topic:s,relay:n,expiry:o,active:!1};return await this.pairings.set(s,h),await this.core.crypto.setSymKey(a,s),await this.core.relayer.subscribe(s,{relay:n}),this.core.expirer.set(s,o),i.activatePairing&&await this.activate({topic:s}),h},this.activate=async({topic:i})=>{this.isInitialized();const s=q(ie);await this.pairings.update(i,{active:!0,expiry:s}),this.core.expirer.set(i,s)},this.ping=async i=>{this.isInitialized(),await this.isValidPing(i);const{topic:s}=i;if(this.pairings.keys.includes(s)){const a=await this.sendRequest(s,"wc_pairingPing",{}),{done:n,resolve:o,reject:h}=gi();this.events.once(ee("pairing_ping",a),({error:d})=>{d?h(d):o()}),await n()}},this.updateExpiry=async({topic:i,expiry:s})=>{this.isInitialized(),await this.pairings.update(i,{expiry:s})},this.updateMetadata=async({topic:i,metadata:s})=>{this.isInitialized(),await this.pairings.update(i,{peerMetadata:s})},this.getPairings=()=>(this.isInitialized(),this.pairings.values),this.disconnect=async i=>{this.isInitialized(),await this.isValidDisconnect(i);const{topic:s}=i;this.pairings.keys.includes(s)&&(await this.sendRequest(s,"wc_pairingDelete",F("USER_DISCONNECTED")),await this.deletePairing(s))},this.sendRequest=async(i,s,a)=>{const n=_e(s,a),o=await this.core.crypto.encode(i,n),h=U[s].req;return this.core.history.set(i,n),await this.core.relayer.publish(i,o,h),n.id},this.sendResult=async(i,s,a)=>{const n=Ce(i,a),o=await this.core.crypto.encode(s,n),h=await this.core.history.get(s,i),d=U[h.request.method].res;await this.core.relayer.publish(s,o,d),await this.core.history.resolve(n)},this.sendError=async(i,s,a)=>{const n=Si(i,a),o=await this.core.crypto.encode(s,n),h=await this.core.history.get(s,i),d=U[h.request.method]?U[h.request.method].res:U.unregistered_method.res;await this.core.relayer.publish(s,o,d),await this.core.history.resolve(n)},this.deletePairing=async(i,s)=>{await this.core.relayer.unsubscribe(i),await Promise.all([this.pairings.delete(i,F("USER_DISCONNECTED")),this.core.crypto.deleteSymKey(i),s?Promise.resolve():this.core.expirer.del(i)])},this.cleanup=async()=>{const i=this.pairings.getAll().filter(s=>fe(s.expiry));await Promise.all(i.map(s=>this.deletePairing(s.topic)))},this.onRelayEventRequest=i=>{const{topic:s,payload:a}=i,n=a.method;if(this.pairings.keys.includes(s))switch(n){case"wc_pairingPing":return this.onPairingPingRequest(s,a);case"wc_pairingDelete":return this.onPairingDeleteRequest(s,a);default:return this.onUnknownRpcMethodRequest(s,a)}},this.onRelayEventResponse=async i=>{const{topic:s,payload:a}=i,n=(await this.core.history.get(s,a.id)).request.method;if(this.pairings.keys.includes(s))switch(n){case"wc_pairingPing":return this.onPairingPingResponse(s,a);default:return this.onUnknownRpcMethodResponse(n)}},this.onPairingPingRequest=async(i,s)=>{const{id:a}=s;try{this.isValidPing({topic:i}),await this.sendResult(a,i,!0),this.events.emit("pairing_ping",{id:a,topic:i})}catch(n){await this.sendError(a,i,n),this.logger.error(n)}},this.onPairingPingResponse=(i,s)=>{const{id:a}=s;setTimeout(()=>{Ti(s)?this.events.emit(ee("pairing_ping",a),{}):Re(s)&&this.events.emit(ee("pairing_ping",a),{error:s.error})},500)},this.onPairingDeleteRequest=async(i,s)=>{const{id:a}=s;try{this.isValidDisconnect({topic:i}),await this.deletePairing(i),this.events.emit("pairing_delete",{id:a,topic:i})}catch(n){await this.sendError(a,i,n),this.logger.error(n)}},this.onUnknownRpcMethodRequest=async(i,s)=>{const{id:a,method:n}=s;try{if(this.registeredMethods.includes(n))return;const o=F("WC_METHOD_UNSUPPORTED",n);await this.sendError(a,i,o),this.logger.error(o)}catch(o){await this.sendError(a,i,o),this.logger.error(o)}},this.onUnknownRpcMethodResponse=i=>{this.registeredMethods.includes(i)||this.logger.error(F("WC_METHOD_UNSUPPORTED",i))},this.isValidPair=i=>{if(!te(i)){const{message:s}=c("MISSING_OR_INVALID",`pair() params: ${i}`);throw new Error(s)}if(!pi(i.uri)){const{message:s}=c("MISSING_OR_INVALID",`pair() uri: ${i.uri}`);throw new Error(s)}},this.isValidPing=async i=>{if(!te(i)){const{message:a}=c("MISSING_OR_INVALID",`ping() params: ${i}`);throw new Error(a)}const{topic:s}=i;await this.isValidPairingTopic(s)},this.isValidDisconnect=async i=>{if(!te(i)){const{message:a}=c("MISSING_OR_INVALID",`disconnect() params: ${i}`);throw new Error(a)}const{topic:s}=i;await this.isValidPairingTopic(s)},this.isValidPairingTopic=async i=>{if(!Di(i,!1)){const{message:s}=c("MISSING_OR_INVALID",`pairing topic should be a string: ${i}`);throw new Error(s)}if(!this.pairings.keys.includes(i)){const{message:s}=c("NO_MATCHING_KEY",`pairing topic doesn't exist: ${i}`);throw new Error(s)}if(fe(this.pairings.get(i).expiry)){await this.deletePairing(i);const{message:s}=c("EXPIRED",`pairing topic: ${i}`);throw new Error(s)}},this.core=e,this.logger=m(t,this.name),this.pairings=new Pt(this.core,this.logger,this.name,this.storagePrefix)}get context(){return f(this.logger)}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}registerRelayerEvents(){this.core.relayer.on(D.message,async e=>{const{topic:t,message:i}=e;if(this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i)))return;const s=await this.core.crypto.decode(t,i);Ie(s)?(this.core.history.set(t,s),this.onRelayEventRequest({topic:t,payload:s})):Pi(s)&&(await this.core.history.resolve(s),this.onRelayEventResponse({topic:t,payload:s}))})}registerExpirerEvents(){this.core.expirer.on(E.expired,async e=>{const{topic:t}=yi(e.target);t&&this.pairings.keys.includes(t)&&(await this.deletePairing(t,!0),this.events.emit("pairing_expire",{topic:t}))})}}class Ot extends qt{constructor(e,t){super(e,t),this.core=e,this.logger=t,this.records=new Map,this.events=new A,this.name=gt,this.version=pt,this.cached=[],this.initialized=!1,this.storagePrefix=P,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(i=>this.records.set(i.id,i)),this.cached=[],this.registerEventListeners(),this.initialized=!0)},this.set=(i,s,a)=>{if(this.isInitialized(),this.logger.debug("Setting JSON-RPC request history record"),this.logger.trace({type:"method",method:"set",topic:i,request:s,chainId:a}),this.records.has(s.id))return;const n={id:s.id,topic:i,request:{method:s.method,params:s.params||null},chainId:a};this.records.set(n.id,n),this.events.emit(C.created,n)},this.resolve=async i=>{if(this.isInitialized(),this.logger.debug("Updating JSON-RPC response history record"),this.logger.trace({type:"method",method:"update",response:i}),!this.records.has(i.id))return;const s=await this.getRecord(i.id);typeof s.response>"u"&&(s.response=Re(i)?{error:i.error}:{result:i.result},this.records.set(s.id,s),this.events.emit(C.updated,s))},this.get=async(i,s)=>(this.isInitialized(),this.logger.debug("Getting record"),this.logger.trace({type:"method",method:"get",topic:i,id:s}),await this.getRecord(s)),this.delete=(i,s)=>{this.isInitialized(),this.logger.debug("Deleting record"),this.logger.trace({type:"method",method:"delete",id:s}),this.values.forEach(a=>{if(a.topic===i){if(typeof s<"u"&&a.id!==s)return;this.records.delete(a.id),this.events.emit(C.deleted,a)}})},this.exists=async(i,s)=>(this.isInitialized(),this.records.has(s)?(await this.getRecord(s)).topic===i:!1),this.on=(i,s)=>{this.events.on(i,s)},this.once=(i,s)=>{this.events.once(i,s)},this.off=(i,s)=>{this.events.off(i,s)},this.removeListener=(i,s)=>{this.events.removeListener(i,s)},this.logger=m(t,this.name)}get context(){return f(this.logger)}get storageKey(){return this.storagePrefix+this.version+"//"+this.name}get size(){return this.records.size}get keys(){return Array.from(this.records.keys())}get values(){return Array.from(this.records.values())}get pending(){const e=[];return this.values.forEach(t=>{if(typeof t.response<"u")return;const i={topic:t.topic,request:_e(t.request.method,t.request.params,t.id),chainId:t.chainId};return e.push(i)}),e}async setJsonRpcRecords(e){await this.core.storage.setItem(this.storageKey,e)}async getJsonRpcRecords(){return await this.core.storage.getItem(this.storageKey)}getRecord(e){this.isInitialized();const t=this.records.get(e);if(!t){const{message:i}=c("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(i)}return t}async persist(){await this.setJsonRpcRecords(this.values),this.events.emit(C.sync)}async restore(){try{const e=await this.getJsonRpcRecords();if(typeof e>"u"||!e.length)return;if(this.records.size){const{message:t}=c("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",records:this.values})}catch(e){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(e)}}registerEventListeners(){this.events.on(C.created,e=>{const t=C.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e}),this.persist()}),this.events.on(C.updated,e=>{const t=C.updated;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e}),this.persist()}),this.events.on(C.deleted,e=>{const t=C.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e}),this.persist()})}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}class At extends Gt{constructor(e,t){super(e,t),this.core=e,this.logger=t,this.expirations=new Map,this.events=new A,this.name=Dt,this.version=yt,this.cached=[],this.initialized=!1,this.storagePrefix=P,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(i=>this.expirations.set(i.target,i)),this.cached=[],this.registerEventListeners(),this.initialized=!0)},this.has=i=>{try{const s=this.formatTarget(i);return typeof this.getExpiration(s)<"u"}catch{return!1}},this.set=(i,s)=>{this.isInitialized();const a=this.formatTarget(i),n={target:a,expiry:s};this.expirations.set(a,n),this.checkExpiry(a,n),this.events.emit(E.created,{target:a,expiration:n})},this.get=i=>{this.isInitialized();const s=this.formatTarget(i);return this.getExpiration(s)},this.del=i=>{if(this.isInitialized(),this.has(i)){const s=this.formatTarget(i),a=this.getExpiration(s);this.expirations.delete(s),this.events.emit(E.deleted,{target:s,expiration:a})}},this.on=(i,s)=>{this.events.on(i,s)},this.once=(i,s)=>{this.events.once(i,s)},this.off=(i,s)=>{this.events.off(i,s)},this.removeListener=(i,s)=>{this.events.removeListener(i,s)},this.logger=m(t,this.name)}get context(){return f(this.logger)}get storageKey(){return this.storagePrefix+this.version+"//"+this.name}get length(){return this.expirations.size}get keys(){return Array.from(this.expirations.keys())}get values(){return Array.from(this.expirations.values())}formatTarget(e){if(typeof e=="string")return bi(e);if(typeof e=="number")return mi(e);const{message:t}=c("UNKNOWN_TYPE",`Target type: ${typeof e}`);throw new Error(t)}async setExpirations(e){await this.core.storage.setItem(this.storageKey,e)}async getExpirations(){return await this.core.storage.getItem(this.storageKey)}async persist(){await this.setExpirations(this.values),this.events.emit(E.sync)}async restore(){try{const e=await this.getExpirations();if(typeof e>"u"||!e.length)return;if(this.expirations.size){const{message:t}=c("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored expirations for ${this.name}`),this.logger.trace({type:"method",method:"restore",expirations:this.values})}catch(e){this.logger.debug(`Failed to Restore expirations for ${this.name}`),this.logger.error(e)}}getExpiration(e){const t=this.expirations.get(e);if(!t){const{message:i}=c("NO_MATCHING_KEY",`${this.name}: ${e}`);throw this.logger.error(i),new Error(i)}return t}checkExpiry(e,t){const{expiry:i}=t;we(i)-Date.now()<=0&&this.expire(e,t)}expire(e,t){this.expirations.delete(e),this.events.emit(E.expired,{target:e,expiration:t})}checkExpirations(){this.core.relayer.connected&&this.expirations.forEach((e,t)=>this.checkExpiry(t,e))}registerEventListeners(){this.core.heartbeat.on(X.pulse,()=>this.checkExpirations()),this.events.on(E.created,e=>{const t=E.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()}),this.events.on(E.expired,e=>{const t=E.expired;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()}),this.events.on(E.deleted,e=>{const t=E.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()})}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}class zt extends Yt{constructor(e,t){super(e,t),this.projectId=e,this.logger=t,this.name=ue,this.initialized=!1,this.init=async i=>{fi()||!Ei()||(this.verifyUrl=i?.verifyUrl||le,await this.createIframe())},this.register=async i=>{var s;this.initialized||await this.init(),this.iframe&&((s=this.iframe.contentWindow)==null||s.postMessage(i.attestationId,this.verifyUrl),this.logger.info(`postMessage sent: ${i.attestationId} ${this.verifyUrl}`))},this.resolve=async i=>{var s;if(this.isDevEnv)return"";this.logger.info(`resolving attestation: ${i.attestationId}`);const a=this.startAbortTimer(se),n=await fetch(`${this.verifyUrl}/attestation/${i.attestationId}`,{signal:this.abortController.signal});return clearTimeout(a),n.status===200?(s=await n.json())==null?void 0:s.origin:""},this.createIframe=async()=>{try{const i=this.startAbortTimer(se);await Promise.race([new Promise((s,a)=>{const n=document.createElement("iframe");n.setAttribute("id",ue),n.setAttribute("src",`${this.verifyUrl}/${this.projectId}`),n.style.display="none",n.addEventListener("load",()=>{this.initialized=!0,clearTimeout(i),s()}),n.addEventListener("error",o=>{a(o)}),document.body.append(n),this.iframe=n}),new Promise(s=>{this.abortController.signal.addEventListener("abort",()=>{s("iframe load timeout")})})])}catch(i){this.logger.error(`Verify iframe failed to load: ${this.verifyUrl}`),this.logger.error(i)}},this.logger=m(t,this.name),this.verifyUrl=le,this.abortController=new AbortController,this.isDevEnv=wi()&&process.env.IS_VITEST}get context(){return f(this.logger)}startAbortTimer(e){return setTimeout(()=>this.abortController.abort(),q(e))}}var Er=Object.defineProperty,Nt=Object.getOwnPropertySymbols,wr=Object.prototype.hasOwnProperty,vr=Object.prototype.propertyIsEnumerable,Ut=(r,e,t)=>e in r?Er(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,Lt=(r,e)=>{for(var t in e||(e={}))wr.call(e,t)&&Ut(r,t,e[t]);if(Nt)for(var t of Nt(e))vr.call(e,t)&&Ut(r,t,e[t]);return r};class J extends Jt{constructor(e){super(e),this.protocol=oe,this.version=Ve,this.name=Y,this.events=new A,this.initialized=!1,this.on=(i,s)=>this.events.on(i,s),this.once=(i,s)=>this.events.once(i,s),this.off=(i,s)=>this.events.off(i,s),this.removeListener=(i,s)=>this.events.removeListener(i,s),this.projectId=e?.projectId,this.relayUrl=e?.relayUrl||ce;const t=typeof e?.logger<"u"&&typeof e?.logger!="string"?e.logger:ge(pe({level:e?.logger||qe.logger}));this.logger=m(t,this.name),this.heartbeat=new Mt,this.crypto=new mt(this,this.logger,e?.keychain),this.history=new Ot(this,this.logger),this.expirer=new At(this,this.logger),this.storage=e!=null&&e.storage?e.storage:new $t(Lt(Lt({},Ge),e?.storageOptions)),this.relayer=new _t({core:this,logger:this.logger,relayUrl:this.relayUrl,projectId:this.projectId}),this.pairing=new xt(this,this.logger),this.verify=new zt(this.projectId||"",this.logger)}static async init(e){const t=new J(e);return await t.initialize(),t}get context(){return f(this.logger)}async start(){this.initialized||await this.initialize()}async initialize(){this.logger.trace("Initialized");try{await this.crypto.init(),await this.history.init(),await this.expirer.init(),await this.relayer.init(),await this.heartbeat.init(),await this.pairing.init(),this.initialized=!0,this.logger.info("Core Initialization Success")}catch(e){throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`,e),this.logger.error(e.message),e}}}const Ir=J;export{Y as CORE_CONTEXT,qe as CORE_DEFAULT,oe as CORE_PROTOCOL,Ge as CORE_STORAGE_OPTIONS,P as CORE_STORAGE_PREFIX,Ve as CORE_VERSION,he as CRYPTO_CLIENT_SEED,Ye as CRYPTO_CONTEXT,Je as CRYPTO_JWT_TTL,Ir as Core,mt as Crypto,Dt as EXPIRER_CONTEXT,nr as EXPIRER_DEFAULT_TTL,E as EXPIRER_EVENTS,yt as EXPIRER_STORAGE_VERSION,At as Expirer,gt as HISTORY_CONTEXT,C as HISTORY_EVENTS,pt as HISTORY_STORAGE_VERSION,Ot as JsonRpcHistory,He as KEYCHAIN_CONTEXT,Xe as KEYCHAIN_STORAGE_VERSION,bt as KeyChain,We as MESSAGES_CONTEXT,Ze as MESSAGES_STORAGE_VERSION,ft as MessageTracker,lt as PAIRING_CONTEXT,rr as PAIRING_DEFAULT_TTL,U as PAIRING_RPC_OPTS,dt as PAIRING_STORAGE_VERSION,ut as PENDING_SUB_RESOLUTION_TIMEOUT,et as PUBLISHER_CONTEXT,Qe as PUBLISHER_DEFAULT_TTL,xt as Pairing,st as RELAYER_CONTEXT,it as RELAYER_DEFAULT_LOGGER,tt as RELAYER_DEFAULT_PROTOCOL,ce as RELAYER_DEFAULT_RELAY_URL,D as RELAYER_EVENTS,N as RELAYER_PROVIDER_EVENTS,nt as RELAYER_RECONNECT_TIMEOUT,at as RELAYER_SDK_VERSION,ir as RELAYER_STORAGE_OPTIONS,rt as RELAYER_SUBSCRIBER_SUFFIX,_t as Relayer,ot as STORE_STORAGE_VERSION,ht as SUBSCRIBER_CONTEXT,sr as SUBSCRIBER_DEFAULT_TTL,I as SUBSCRIBER_EVENTS,ct as SUBSCRIBER_STORAGE_VERSION,Pt as Store,vt as Subscriber,ue as VERIFY_CONTEXT,le as VERIFY_SERVER,zt as Verify,J as default};
//# sourceMappingURL=index.es.js.map
