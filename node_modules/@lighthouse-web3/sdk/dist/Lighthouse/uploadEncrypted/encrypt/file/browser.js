"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* istanbul ignore file */
const axios_1 = __importDefault(require("axios"));
const form_data_1 = __importDefault(require("form-data"));
const kavach_1 = require("@lighthouse-web3/kavach");
const encryptionBrowser_1 = require("../../encryptionBrowser");
const lighthouse_config_1 = require("../../../../lighthouse.config");
const readFileAsync = (file) => {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
            reader.result && resolve(reader.result);
        };
        reader.onerror = reject;
        reader.readAsArrayBuffer(file);
    });
};
exports.default = async (e, apiKey, publicKey, signedMessage, uploadProgressCallback = (data) => { }) => {
    try {
        // Generate fileEncryptionKey
        const { masterKey: fileEncryptionKey, keyShards } = await (0, kavach_1.generate)();
        // Upload file
        e.persist();
        let mimeType = null;
        if (e.target.files.length === 1) {
            mimeType = e.target.files[0].type;
        }
        const endpoint = lighthouse_config_1.lighthouseConfig.lighthouseNode + '/api/v0/add';
        const token = 'Bearer ' + apiKey;
        const fileArr = [];
        for (let i = 0; i < e.target.files.length; i++) {
            fileArr.push(e.target.files[i]);
        }
        const formData = new form_data_1.default();
        const boundary = Symbol();
        const filesParam = await Promise.all(fileArr.map(async (f) => {
            const fileData = await readFileAsync(f);
            const encryptedData = await (0, encryptionBrowser_1.encryptFile)(fileData, fileEncryptionKey);
            return {
                data: new Blob([encryptedData], { type: f.type }),
                fileName: f.name,
            };
        }));
        filesParam.forEach(function (item_) {
            return formData.append('file', item_.data, item_.fileName ? item_.fileName : 'file');
        });
        const response = await axios_1.default.post(endpoint, formData, {
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            headers: {
                'Content-type': `multipart/form-data; boundary= ${boundary.toString()}`,
                Encryption: `${true}`,
                'Mime-Type': mimeType,
                Authorization: token,
            },
            onUploadProgress: function (progressEvent) {
                const _progress = Math.round(progressEvent.loaded / progressEvent.total);
                uploadProgressCallback({
                    progress: _progress,
                    total: progressEvent.total,
                    uploaded: progressEvent.loaded,
                });
            },
        });
        const { isSuccess, error } = await (0, kavach_1.saveShards)(publicKey, response.data.Hash, signedMessage, keyShards);
        if (error) {
            throw new Error('Error encrypting file');
        }
        // return response
        /*
          {
            data: {
              Name: 'flow1.png',
              Hash: 'QmUHDKv3NNL1mrg4NTW4WwJqetzwZbGNitdjr2G6Z5Xe6s',
              Size: '31735'
            }
          }
        */
        return { data: response.data };
    }
    catch (error) {
        return error.message;
    }
};
