import{RELAYER_EVENTS as j,Core as V,Store as E}from"@walletconnect/core";import{pino as z,getDefaultLoggerOptions as M,generateChildLogger as J,getLoggerContext as X}from"@walletconnect/logger";import{EventEmitter as F}from"events";import{formatJsonRpcRequest as H,formatJsonRpcResult as Y,formatJsonRpcError as k,isJsonRpcResult as G,isJsonRpcError as B,isJsonRpcRequest as Q,isJsonRpcResponse as Z}from"@walletconnect/jsonrpc-utils";import{isValidUrl as W,isValidRequestExpiry as ee,getInternalError as T,hashKey as A,TYPE_1 as te}from"@walletconnect/utils";import{ONE_DAY as R,FIVE_MINUTES as ie,SEVEN_DAYS as se}from"@walletconnect/time";import{hashMessage as b}from"@ethersproject/hash";import{recoverAddress as re}from"@ethersproject/transactions";import ne from"isomorphic-unfetch";import{randomStringForEntropy as oe}from"@stablelib/random";class P{constructor(i){this.client=i}}class O{constructor(i){this.opts=i}}const C="https://rpc.walletconnect.com/v1",y={wc_authRequest:{req:{ttl:R,prompt:!0,tag:3e3},res:{ttl:R,prompt:!1,tag:3001}}},w={min:ie,max:se},I="wc",S=1,N="auth",q="authClient",m=`${I}@${1}:${N}:`,g=`${m}:PUB_KEY`,ae="expirer",ce={created:"expirer_created",deleted:"expirer_deleted",expired:"expirer_expired",sync:"expirer_sync"},he="0.3",le=R;function v(r){return r?.split(":")}function ue(r){const i=r&&v(r);if(i)return i[3]}function pe(r){const i=r&&v(r);if(i)return i[2]+":"+i[3]}function $(r){const i=r&&v(r);if(i)return i.pop()}async function de(r,i,e,t,s){switch(e.t){case"eip191":return ge(r,i,e.s);case"eip1271":return await ye(r,i,e.s,t,s);default:throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${e.t}`)}}function ge(r,i,e){return re(b(i),e).toLowerCase()===r.toLowerCase()}async function ye(r,i,e,t,s){try{const n="0x1626ba7e",o="0000000000000000000000000000000000000000000000000000000000000040",a="0000000000000000000000000000000000000000000000000000000000000041",h=e.substring(2),c=b(i).substring(2),l=n+c+o+a+h,d=await ne(`${C}/?chainId=${t}&projectId=${s}`,{method:"POST",body:JSON.stringify({id:me(),jsonrpc:"2.0",method:"eth_call",params:[{to:r,data:l},"latest"]})}),{result:p}=await d.json();return p?p.slice(0,n.length).toLowerCase()===n.toLowerCase():!1}catch(n){return console.error("isValidEip1271Signature: ",n),!1}}function me(){return Date.now()+Math.floor(Math.random()*1e3)}function x(r){return r.getAll().filter(i=>"requester"in i)}function L(r,i){return x(r).find(e=>e.id===i)}function we(r){const i=W(r.aud),e=new RegExp(`${r.domain}`).test(r.aud),t=!!r.nonce,s=r.type?r.type==="eip4361":!0,n=r.expiry;if(n&&!ee(n,w)){const{message:o}=T("MISSING_OR_INVALID",`request() expiry: ${n}. Expiry must be a number (in seconds) between ${w.min} and ${w.max}`);throw new Error(o)}return!!(i&&e&&t&&s)}function fe(r,i){return!!L(i,r.id)}var Ee=Object.defineProperty,Re=Object.defineProperties,Ie=Object.getOwnPropertyDescriptors,K=Object.getOwnPropertySymbols,qe=Object.prototype.hasOwnProperty,ve=Object.prototype.propertyIsEnumerable,U=(r,i,e)=>i in r?Ee(r,i,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[i]=e,_=(r,i)=>{for(var e in i||(i={}))qe.call(i,e)&&U(r,e,i[e]);if(K)for(var e of K(i))ve.call(i,e)&&U(r,e,i[e]);return r},_e=(r,i)=>Re(r,Ie(i));class Te extends P{constructor(i){super(i),this.initialized=!1,this.name="authEngine",this.init=()=>{this.initialized||(this.registerRelayerEvents(),this.client.core.pairing.register({methods:Object.keys(y)}),this.initialized=!0)},this.request=async(e,t)=>{if(this.isInitialized(),!we(e))throw new Error("Invalid request");if(t!=null&&t.topic)return await this.requestOnKnownPairing(t.topic,e);const{chainId:s,statement:n,aud:o,domain:a,nonce:h,type:c}=e,{topic:l,uri:d}=await this.client.core.pairing.create();this.client.logger.info({message:"Generated new pairing",pairing:{topic:l,uri:d}});const p=await this.client.core.crypto.generateKeyPair(),u=A(p);await this.client.authKeys.set(g,{responseTopic:u,publicKey:p}),await this.client.pairingTopics.set(u,{topic:u,pairingTopic:l}),await this.client.core.relayer.subscribe(u),this.client.logger.info(`sending request to new pairing topic: ${l}`);const D=await this.sendRequest(l,"wc_authRequest",{payloadParams:{type:c??"eip4361",chainId:s,statement:n,aud:o,domain:a,version:"1",nonce:h,iat:new Date().toISOString()},requester:{publicKey:p,metadata:this.client.metadata}},{},e.expiry);return this.client.logger.info(`sent request to new pairing topic: ${l}`),{uri:d,id:D}},this.respond=async(e,t)=>{if(this.isInitialized(),!fe(e,this.client.requests))throw new Error("Invalid response");const s=L(this.client.requests,e.id),n=s.requester.publicKey,o=await this.client.core.crypto.generateKeyPair(),a=A(n),h={type:te,receiverPublicKey:n,senderPublicKey:o};if("error"in e){await this.sendError(s.id,a,e,h);return}const c={h:{t:"eip4361"},p:_e(_({},s.cacaoPayload),{iss:t}),s:e.signature},l=await this.sendResult(s.id,a,c,h);await this.client.requests.set(l,_({id:l},c))},this.getPendingRequests=()=>x(this.client.requests),this.formatMessage=(e,t)=>{this.client.logger.debug(`formatMessage, cacao is: ${JSON.stringify(e)}`);const s=`${e.domain} wants you to sign in with your Ethereum account:`,n=$(t),o=e.statement,a=`URI: ${e.aud}`,h=`Version: ${e.version}`,c=`Chain ID: ${ue(t)}`,l=`Nonce: ${e.nonce}`,d=`Issued At: ${e.iat}`,p=e.resources&&e.resources.length>0?`Resources:
${e.resources.map(u=>`- ${u}`).join(`
`)}`:void 0;return[s,n,"",o,"",a,h,c,l,d,p].filter(u=>u!=null).join(`
`)},this.setExpiry=async(e,t)=>{this.client.core.pairing.pairings.keys.includes(e)&&await this.client.core.pairing.updateExpiry({topic:e,expiry:t}),this.client.core.expirer.set(e,t)},this.sendRequest=async(e,t,s,n,o)=>{const a=H(t,s),h=await this.client.core.crypto.encode(e,a,n),c=y[t].req;return o&&(c.ttl=o),this.client.core.history.set(e,a),await this.client.core.relayer.publish(e,h,c),a.id},this.sendResult=async(e,t,s,n)=>{const o=Y(e,s),a=await this.client.core.crypto.encode(t,o,n),h=await this.client.core.history.get(t,e),c=y[h.request.method].res;return await this.client.core.relayer.publish(t,a,c),await this.client.core.history.resolve(o),o.id},this.sendError=async(e,t,s,n)=>{const o=k(e,s.error),a=await this.client.core.crypto.encode(t,o,n),h=await this.client.core.history.get(t,e),c=y[h.request.method].res;return await this.client.core.relayer.publish(t,a,c),await this.client.core.history.resolve(o),o.id},this.requestOnKnownPairing=async(e,t)=>{const s=this.client.core.pairing.pairings.getAll({active:!0}).find(u=>u.topic===e);if(!s)throw new Error(`Could not find pairing for provided topic ${e}`);const{publicKey:n}=this.client.authKeys.get(g),{chainId:o,statement:a,aud:h,domain:c,nonce:l,type:d}=t,p=await this.sendRequest(s.topic,"wc_authRequest",{payloadParams:{type:d??"eip4361",chainId:o,statement:a,aud:h,domain:c,version:"1",nonce:l,iat:new Date().toISOString()},requester:{publicKey:n,metadata:this.client.metadata}},{},t.expiry);return this.client.logger.info(`sent request to known pairing topic: ${s.topic}`),{id:p}},this.onRelayEventRequest=e=>{const{topic:t,payload:s}=e,n=s.method;switch(n){case"wc_authRequest":return this.onAuthRequest(t,s);default:return this.client.logger.info(`Unsupported request method ${n}`)}},this.onRelayEventResponse=async e=>{const{topic:t,payload:s}=e,n=(await this.client.core.history.get(t,s.id)).request.method;switch(n){case"wc_authRequest":return this.onAuthResponse(t,s);default:return this.client.logger.info(`Unsupported response method ${n}`)}},this.onAuthRequest=async(e,t)=>{const{requester:s,payloadParams:{resources:n,statement:o,aud:a,domain:h,version:c,nonce:l,iat:d,chainId:p}}=t.params;this.client.logger.info({type:"onAuthRequest",topic:e,payload:t});try{const u={aud:a,domain:h,version:c,nonce:l,iat:d,statement:o,resources:n,chainId:p};await this.client.requests.set(t.id,{requester:s,id:t.id,cacaoPayload:u}),this.client.emit("auth_request",{id:t.id,topic:e,params:{requester:s,cacaoPayload:u}})}catch(u){await this.sendError(t.id,e,u),this.client.logger.error(u)}},this.onAuthResponse=async(e,t)=>{const{id:s}=t;if(this.client.logger.info({type:"onAuthResponse",topic:e,response:t}),G(t)){const{pairingTopic:n}=this.client.pairingTopics.get(e);await this.client.core.pairing.activate({topic:n});const{s:o,p:a}=t.result;await this.client.requests.set(s,_({id:s},t.result));const h=this.formatMessage(a,a.iss);this.client.logger.debug(`reconstructed message:
`,JSON.stringify(h)),this.client.logger.debug("payload.iss:",a.iss),this.client.logger.debug("signature:",o);const c=$(a.iss),l=pe(a.iss);if(!c)throw new Error("Could not derive address from `payload.iss`");if(!l)throw new Error("Could not derive chainId from `payload.iss`");this.client.logger.debug("walletAddress extracted from `payload.iss`:",c),await de(c,h,o,l,this.client.projectId)?this.client.emit("auth_response",{id:s,topic:e,params:t}):this.client.emit("auth_response",{id:s,topic:e,params:{message:"Invalid signature",code:-1}})}else B(t)&&this.client.emit("auth_response",{id:s,topic:e,params:t})}}isInitialized(){if(!this.initialized){const{message:i}=T("NOT_INITIALIZED",this.name);throw new Error(i)}}registerRelayerEvents(){this.client.core.relayer.on(j.message,async i=>{const{topic:e,message:t}=i,{responseTopic:s,publicKey:n}=this.client.authKeys.keys.includes(g)?this.client.authKeys.get(g):{responseTopic:void 0,publicKey:void 0};if(s&&e!==s){this.client.logger.debug("[Auth] Ignoring message from unknown topic",e);return}const o=await this.client.core.crypto.decode(e,t,{receiverPublicKey:n});Q(o)?(this.client.core.history.set(e,o),this.onRelayEventRequest({topic:e,payload:o})):Z(o)&&(await this.client.core.history.resolve(o),this.onRelayEventResponse({topic:e,payload:o}))})}}class f extends O{constructor(i){super(i),this.protocol=I,this.version=S,this.name=q,this.events=new F,this.emit=(t,s)=>this.events.emit(t,s),this.on=(t,s)=>this.events.on(t,s),this.once=(t,s)=>this.events.once(t,s),this.off=(t,s)=>this.events.off(t,s),this.removeListener=(t,s)=>this.events.removeListener(t,s),this.request=async(t,s)=>{try{return await this.engine.request(t,s)}catch(n){throw this.logger.error(n.message),n}},this.respond=async(t,s)=>{try{return await this.engine.respond(t,s)}catch(n){throw this.logger.error(n.message),n}},this.getPendingRequests=()=>{try{return this.engine.getPendingRequests()}catch(t){throw this.logger.error(t.message),t}},this.formatMessage=(t,s)=>{try{return this.engine.formatMessage(t,s)}catch(n){throw this.logger.error(n.message),n}};const e=typeof i.logger<"u"&&typeof i.logger!="string"?i.logger:z(M({level:i.logger||"error"}));this.name=i?.name||q,this.metadata=i.metadata,this.projectId=i.projectId,this.core=i.core||new V(i),this.logger=J(e,this.name),this.authKeys=new E(this.core,this.logger,"authKeys",m,()=>g),this.pairingTopics=new E(this.core,this.logger,"pairingTopics",m),this.requests=new E(this.core,this.logger,"requests",m),this.engine=new Te(this)}static async init(i){const e=new f(i);return await e.initialize(),e}get context(){return X(this.logger)}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.authKeys.init(),await this.requests.init(),await this.pairingTopics.init(),await this.engine.init(),this.logger.info("AuthClient Initialization Success"),this.logger.info({authClient:this})}catch(i){throw this.logger.info("AuthClient Initialization Failure"),this.logger.error(i.message),i}}}function Ae(){return oe(96)}const be=f;export{N as AUTH_CLIENT_CONTEXT,q as AUTH_CLIENT_DEFAULT_NAME,I as AUTH_CLIENT_PROTOCOL,g as AUTH_CLIENT_PUBLIC_KEY_NAME,m as AUTH_CLIENT_STORAGE_PREFIX,S as AUTH_CLIENT_VERSION,w as AUTH_REQUEST_EXPIRY_BOUNDARIES,be as AuthClient,C as DEFAULT_RPC_URL,y as ENGINE_RPC_OPTS,ae as EXPIRER_CONTEXT,le as EXPIRER_DEFAULT_TTL,ce as EXPIRER_EVENTS,he as EXPIRER_STORAGE_VERSION,O as IAuthClient,P as IAuthEngine,f as default,Ae as generateNonce};
//# sourceMappingURL=index.es.js.map
