/// <reference types="node" />
import { ICore, IStore, CoreTypes } from "@walletconnect/types";
import EventEmitter from "events";
import { AuthEngineTypes } from "./engine";
import { IAuthEngine } from "../types";
import { JsonRpcError, JsonRpcResult } from "@walletconnect/jsonrpc-utils";
import { Logger } from "@walletconnect/logger";
export declare namespace AuthClientTypes {
    type Event = "auth_request" | "auth_response";
    interface AuthRequestEventArgs {
        requester: AuthEngineTypes.PendingRequest["requester"];
        cacaoPayload: AuthEngineTypes.CacaoRequestPayload;
    }
    type AuthResponseEventArgs = {
        message: string;
        code: number;
    } | JsonRpcResult<AuthEngineTypes.Cacao> | JsonRpcError;
    interface BaseEventArgs<T = unknown> {
        id: number;
        topic: string;
        params: T;
    }
    interface EventArguments {
        auth_request: BaseEventArgs<AuthRequestEventArgs>;
        auth_response: BaseEventArgs<AuthResponseEventArgs>;
    }
    interface Options extends CoreTypes.Options {
        metadata: Metadata;
        core?: ICore;
        projectId: string;
    }
    interface Metadata {
        name: string;
        description: string;
        url: string;
        icons: string[];
        redirect?: {
            native?: string;
            universal?: string;
        };
    }
}
export declare abstract class IAuthClient {
    opts: AuthClientTypes.Options;
    abstract readonly protocol: string;
    abstract readonly version: number;
    abstract readonly name: string;
    abstract core: ICore;
    abstract metadata: AuthClientTypes.Metadata;
    abstract projectId: string;
    abstract authKeys: IStore<string, {
        responseTopic: string;
        publicKey: string;
    }>;
    abstract pairingTopics: IStore<string, {
        topic: string;
        pairingTopic: string;
    }>;
    abstract requests: IStore<number, {
        id: number;
    } & (AuthEngineTypes.Cacao | AuthEngineTypes.PendingRequest)>;
    abstract events: EventEmitter;
    abstract logger: Logger;
    abstract engine: IAuthEngine;
    constructor(opts: AuthClientTypes.Options);
    abstract request: IAuthEngine["request"];
    abstract respond: IAuthEngine["respond"];
    abstract formatMessage: IAuthEngine["formatMessage"];
    abstract getPendingRequests: IAuthEngine["getPendingRequests"];
    abstract emit: <E extends AuthClientTypes.Event>(event: E, args: AuthClientTypes.EventArguments[E]) => boolean;
    abstract on: <E extends AuthClientTypes.Event>(event: E, listener: (args: AuthClientTypes.EventArguments[E]) => void) => EventEmitter;
    abstract once: <E extends AuthClientTypes.Event>(event: E, listener: (args: AuthClientTypes.EventArguments[E]) => void) => EventEmitter;
    abstract off: <E extends AuthClientTypes.Event>(event: E, listener: (args: AuthClientTypes.EventArguments[E]) => void) => EventEmitter;
    abstract removeListener: <E extends AuthClientTypes.Event>(event: E, listener: (args: AuthClientTypes.EventArguments[E]) => void) => EventEmitter;
}
//# sourceMappingURL=client.d.ts.map